# Courses
1. [Google IT Automation with Python (Course 2)](https://www.coursera.org/learn/python-operating-system)

## Interpreted vs. Compiled Languages
**Interpreted Languages**:

1. **Execution**: Interpreted languages are executed line by line, directly by an interpreter software. The code is read and executed sequentially from top to bottom.

2. **Portability**: Code written in an interpreted language is generally more portable because it can run on any platform with the corresponding interpreter.

3. **Debugging**: Debugging is often easier in interpreted languages because errors can be caught and reported as soon as they occur in the code.

4. **Performance**: Interpreted languages tend to have slower execution speed compared to compiled languages because the code is translated and executed on the fly.

**Compiled Languages**:

1. **Compilation**: Compiled languages are first translated into machine code (or intermediate code) by a compiler before execution. This translation step creates a separate executable file.

2. **Execution**: The compiled program is executed directly by the computer's CPU, which can lead to faster execution times compared to interpreted languages.

3. **Portability**: Compiled programs are typically less portable because they are specific to the machine architecture and operating system for which they were compiled.

4. **Debugging**: Debugging in compiled languages can be more challenging since errors are detected during the compilation phase, which may require extra effort to identify and fix.

In summary, interpreted languages are easier to write, more portable, and offer better debugging capabilities but tend to be slower in terms of execution speed. Compiled languages produce faster-running programs but are less portable and can be more challenging to debug. The choice between them depends on the specific needs of a project and the trade-offs you are willing to make.

## Benefits of Automation
- Scalability - When more work is added to a system, the system can do whatever it needs to complete the work
- Centralizing Mistakes

`[time_to_automate < (time_to_perform * amount_of_times_performed*)]`

![https://xkcd.com/1205/](https://imgs.xkcd.com/comics/is_it_worth_the_time.png)
## Pareto Principle
One fifth of the sysadmin tasks you perform comprise four fifths of your total workload.
## I/O Streams
The basic mechanism for performing input and output operations in your programs. Called streams, because the data is always flowing.

- Standard Input (STDIN) - input()
- Standard Output (STDOUT) - print()
- Standard Error (STDERR) - Traceback
## Running System Commands in Python
In simple terms, the `subprocess` module in Python 3 is a built-in module that allows you to run external processes (other programs or commands) from within your Python script. It provides a way to interact with these external processes, capture their output, and control their execution.

Here are some key points to understand about the `subprocess` module:

1. **Running External Commands**: You can use `subprocess` to run external commands or programs, such as command-line utilities or system processes, directly from your Python script.

2. **Capture Output**: You can capture the output (stdout) and error messages (stderr) generated by the external process and use them in your Python code. This allows you to process or display the results.

3. **Communication**: You can interact with the external process by sending input to it and reading its output. This is useful for automating tasks or scripts that require interaction with external programs.

4. **Error Handling**: `subprocess` provides ways to handle errors that may occur during the execution of external processes, such as when a command fails to run.

5. **Control and Management**: You can control various aspects of the subprocess, including setting environment variables, specifying working directories, and more.

Here's a simple example of how you might use the `subprocess` module to run an external command and capture its output:

```python
import subprocess

# Run an external command (e.g., 'ls' to list files in a directory)
result = subprocess.run(['ls', '-l'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

# Print the output and error messages
print("Standard Output:")
print(result.stdout)

print("Standard Error:")
print(result.stderr)
```

In this example, the `subprocess.run()` function runs the 'ls' command to list files in a directory. It captures both the standard output and standard error, which can then be used or processed in your Python script.

Overall, the `subprocess` module is a powerful tool for integrating external processes into your Python applications and automating various system-related tasks.

```Python
import subprocess

subprocess.run(["date"])

# Tue 07 Jan 2023 02:34:44 PM PST
# CompletedProcess(args=['date'], returncode=0)
```

## Unit Tests
In simple terms, the `unittest` module in Python 3 is a built-in library that helps you write and run test cases for your Python code. It is part of the standard library and provides a framework for organizing and running tests to ensure that your code works as expected.

Here are some key points to understand about the `unittest` module:

1. **Test Cases**: You create test cases by defining classes that inherit from `unittest.TestCase`. Each test case class contains one or more test methods, which are regular Python methods that test specific parts of your code.

2. **Assertions**: Inside your test methods, you use various assertion methods provided by `unittest.TestCase` to check whether your code produces the expected results. Common assertions include `assertEqual`, `assertTrue`, `assertFalse`, and more.

3. **Test Discovery**: The `unittest` framework can automatically discover and run your test cases. It looks for methods that start with the word "test" within your test case classes.

4. **Test Suites**: You can group related test cases into test suites. Test suites help you organize and run multiple test cases together.

5. **Setup and Teardown**: You can use special methods `setUp` and `tearDown` to set up initial conditions before each test method and clean up after each test method, respectively.

6. **Test Runner**: Python includes a built-in test runner that you can use to execute your tests. You can run tests from the command line or integrate them into your development environment.

Here's a simple example of writing and running tests using the `unittest` module:

```python
import unittest

# Function to be tested
def add(a, b):
    return a + b

# Test case class
class TestAddition(unittest.TestCase):

    def test_add_positive_numbers(self):
        result = add(2, 3)
        self.assertEqual(result, 5)

    def test_add_negative_numbers(self):
        result = add(-2, -3)
        self.assertEqual(result, -5)

if __name__ == '__main__':
    unittest.main()
```

In this example:

- We define a simple function `add` that adds two numbers.
- We create a test case class `TestAddition` with two test methods, each testing a different scenario for the `add` function.
- We use the `self.assertEqual` assertion to check if the function produces the expected results.
- Finally, we run the tests using `unittest.main()`.

The `unittest` module helps you automate the testing process, ensuring that your code behaves correctly, and makes it easier to catch and fix issues as you develop your software.