# Courses
1. [Google IT Automation with Python (Course 2)](https://www.coursera.org/learn/python-operating-system)

## Interpreted vs. Compiled Languages
**Interpreted Languages**:

1. **Execution**: Interpreted languages are executed line by line, directly by an interpreter software. The code is read and executed sequentially from top to bottom.

2. **Portability**: Code written in an interpreted language is generally more portable because it can run on any platform with the corresponding interpreter.

3. **Debugging**: Debugging is often easier in interpreted languages because errors can be caught and reported as soon as they occur in the code.

4. **Performance**: Interpreted languages tend to have slower execution speed compared to compiled languages because the code is translated and executed on the fly.

**Compiled Languages**:

1. **Compilation**: Compiled languages are first translated into machine code (or intermediate code) by a compiler before execution. This translation step creates a separate executable file.

2. **Execution**: The compiled program is executed directly by the computer's CPU, which can lead to faster execution times compared to interpreted languages.

3. **Portability**: Compiled programs are typically less portable because they are specific to the machine architecture and operating system for which they were compiled.

4. **Debugging**: Debugging in compiled languages can be more challenging since errors are detected during the compilation phase, which may require extra effort to identify and fix.

In summary, interpreted languages are easier to write, more portable, and offer better debugging capabilities but tend to be slower in terms of execution speed. Compiled languages produce faster-running programs but are less portable and can be more challenging to debug. The choice between them depends on the specific needs of a project and the trade-offs you are willing to make.

## Benefits of Automation
- Scalability - When more work is added to a system, the system can do whatever it needs to complete the work
- Centralizing Mistakes

`[time_to_automate < (time_to_perform * amount_of_times_performed*)]`

![https://xkcd.com/1205/](https://imgs.xkcd.com/comics/is_it_worth_the_time.png)
## Pareto Principle
One fifth of the sysadmin tasks you perform comprise four fifths of your total workload.
## I/O Streams
The basic mechanism for performing input and output operations in your programs. Called streams, because the data is always flowing.

- Standard Input (STDIN) - input()
- Standard Output (STDOUT) - print()
- Standard Error (STDERR) - Traceback
## Running System Commands in Python
In simple terms, the `subprocess` module in Python 3 is a built-in module that allows you to run external processes (other programs or commands) from within your Python script. It provides a way to interact with these external processes, capture their output, and control their execution.

Here are some key points to understand about the `subprocess` module:

1. **Running External Commands**: You can use `subprocess` to run external commands or programs, such as command-line utilities or system processes, directly from your Python script.

2. **Capture Output**: You can capture the output (stdout) and error messages (stderr) generated by the external process and use them in your Python code. This allows you to process or display the results.

3. **Communication**: You can interact with the external process by sending input to it and reading its output. This is useful for automating tasks or scripts that require interaction with external programs.

4. **Error Handling**: `subprocess` provides ways to handle errors that may occur during the execution of external processes, such as when a command fails to run.

5. **Control and Management**: You can control various aspects of the subprocess, including setting environment variables, specifying working directories, and more.

Here's a simple example of how you might use the `subprocess` module to run an external command and capture its output:

```python
import subprocess

# Run an external command (e.g., 'ls' to list files in a directory)
result = subprocess.run(['ls', '-l'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

# Print the output and error messages
print("Standard Output:")
print(result.stdout)

print("Standard Error:")
print(result.stderr)
```

In this example, the `subprocess.run()` function runs the 'ls' command to list files in a directory. It captures both the standard output and standard error, which can then be used or processed in your Python script.

Overall, the `subprocess` module is a powerful tool for integrating external processes into your Python applications and automating various system-related tasks.

```Python
import subprocess

subprocess.run(["date"])

# Tue 07 Jan 2023 02:34:44 PM PST
# CompletedProcess(args=['date'], returncode=0)
```