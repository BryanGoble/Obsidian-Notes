---
tags:
  - Python
  - Linux
---

# Courses
1. [Google IT Automation with Python (Course 2)](https://www.coursera.org/learn/python-operating-system)

## Interpreted vs. Compiled Languages
**Interpreted Languages**:

1. **Execution**: Interpreted languages are executed line by line, directly by an interpreter software. The code is read and executed sequentially from top to bottom.

2. **Portability**: Code written in an interpreted language is generally more portable because it can run on any platform with the corresponding interpreter.

3. **Debugging**: Debugging is often easier in interpreted languages because errors can be caught and reported as soon as they occur in the code.

4. **Performance**: Interpreted languages tend to have slower execution speed compared to compiled languages because the code is translated and executed on the fly.

**Compiled Languages**:

1. **Compilation**: Compiled languages are first translated into machine code (or intermediate code) by a compiler before execution. This translation step creates a separate executable file.

2. **Execution**: The compiled program is executed directly by the computer's CPU, which can lead to faster execution times compared to interpreted languages.

3. **Portability**: Compiled programs are typically less portable because they are specific to the machine architecture and operating system for which they were compiled.

4. **Debugging**: Debugging in compiled languages can be more challenging since errors are detected during the compilation phase, which may require extra effort to identify and fix.

In summary, interpreted languages are easier to write, more portable, and offer better debugging capabilities but tend to be slower in terms of execution speed. Compiled languages produce faster-running programs but are less portable and can be more challenging to debug. The choice between them depends on the specific needs of a project and the trade-offs you are willing to make.

## Benefits of Automation
- Scalability - When more work is added to a system, the system can do whatever it needs to complete the work
- Centralizing Mistakes

`[time_to_automate < (time_to_perform * amount_of_times_performed*)]`

![https://xkcd.com/1205/](https://imgs.xkcd.com/comics/is_it_worth_the_time.png)
## Pareto Principle
One fifth of the sysadmin tasks you perform comprise four fifths of your total workload.
## I/O Streams
The basic mechanism for performing input and output operations in your programs. Called streams, because the data is always flowing.

- Standard Input (STDIN) - input()
- Standard Output (STDOUT) - print()
- Standard Error (STDERR) - Traceback
## Running System Commands in Python
In simple terms, the `subprocess` module in Python 3 is a built-in module that allows you to run external processes (other programs or commands) from within your Python script. It provides a way to interact with these external processes, capture their output, and control their execution.

Here are some key points to understand about the `subprocess` module:

1. **Running External Commands**: You can use `subprocess` to run external commands or programs, such as command-line utilities or system processes, directly from your Python script.

2. **Capture Output**: You can capture the output (stdout) and error messages (stderr) generated by the external process and use them in your Python code. This allows you to process or display the results.

3. **Communication**: You can interact with the external process by sending input to it and reading its output. This is useful for automating tasks or scripts that require interaction with external programs.

4. **Error Handling**: `subprocess` provides ways to handle errors that may occur during the execution of external processes, such as when a command fails to run.

5. **Control and Management**: You can control various aspects of the subprocess, including setting environment variables, specifying working directories, and more.

Here's a simple example of how you might use the `subprocess` module to run an external command and capture its output:

```python
import subprocess

# Run an external command (e.g., 'ls' to list files in a directory)
result = subprocess.run(['ls', '-l'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

# Print the output and error messages
print("Standard Output:")
print(result.stdout)

print("Standard Error:")
print(result.stderr)
```

In this example, the `subprocess.run()` function runs the 'ls' command to list files in a directory. It captures both the standard output and standard error, which can then be used or processed in your Python script.

Overall, the `subprocess` module is a powerful tool for integrating external processes into your Python applications and automating various system-related tasks.

```Python
import subprocess

subprocess.run(["date"])

# Tue 07 Jan 2023 02:34:44 PM PST
# CompletedProcess(args=['date'], returncode=0)
```

## Unit Tests
In simple terms, the `unittest` module in Python 3 is a built-in library that helps you write and run test cases for your Python code. It is part of the standard library and provides a framework for organizing and running tests to ensure that your code works as expected.

Here are some key points to understand about the `unittest` module:

1. **Test Cases**: You create test cases by defining classes that inherit from `unittest.TestCase`. Each test case class contains one or more test methods, which are regular Python methods that test specific parts of your code.

2. **Assertions**: Inside your test methods, you use various assertion methods provided by `unittest.TestCase` to check whether your code produces the expected results. Common assertions include `assertEqual`, `assertTrue`, `assertFalse`, and more.

3. **Test Discovery**: The `unittest` framework can automatically discover and run your test cases. It looks for methods that start with the word "test" within your test case classes.

4. **Test Suites**: You can group related test cases into test suites. Test suites help you organize and run multiple test cases together.

5. **Setup and Teardown**: You can use special methods `setUp` and `tearDown` to set up initial conditions before each test method and clean up after each test method, respectively.

6. **Test Runner**: Python includes a built-in test runner that you can use to execute your tests. You can run tests from the command line or integrate them into your development environment.

Here's a simple example of writing and running tests using the `unittest` module:

```python
import unittest

# Function to be tested
def add(a, b):
    return a + b

# Test case class
class TestAddition(unittest.TestCase):

    def test_add_positive_numbers(self):
        result = add(2, 3)
        self.assertEqual(result, 5)

    def test_add_negative_numbers(self):
        result = add(-2, -3)
        self.assertEqual(result, -5)

if __name__ == '__main__':
    unittest.main()
```

In this example:

- We define a simple function `add` that adds two numbers.
- We create a test case class `TestAddition` with two test methods, each testing a different scenario for the `add` function.
- We use the `self.assertEqual` assertion to check if the function produces the expected results.
- Finally, we run the tests using `unittest.main()`.

The `unittest` module helps you automate the testing process, ensuring that your code behaves correctly, and makes it easier to catch and fix issues as you develop your software.

## Basic Linux Commands
### Managing files and directories
- **cd** directory: changes the current working directory to the specified one
- **pwd:** prints the current working directory
- **ls:** lists the contents of the current directory
- **ls** directory: lists the contents of the received directory
- **ls** -l: lists the additional information for the contents of the directory
- **ls** -a: lists all files, including those hidden
- **ls** -la: applies both the -l and the -a flags
- **mkdir** directory: creates the directory with the received name
- **rmdir** directory: deletes the directory with the received name (if empty)
- **cp** `<old_name>` `<new_name>`: copies old_name into new_name
- **mv** `<old_name>` `<new_name>`: moves old_name into new_name
- **touch** `<file_name>`: creates an empty file or updates the modified time if it exists
- **chmod** modifiers files: changes the permissions for the files according to the provided modifiers; we've seen +x to make the file executable
- **chown** user files: changes the owner of the files to the given user
- **chgrp** group files: changes the group of the files to the given group
### Operating with the content of files
- **cat** file: shows the content of the file through standard output
- **wc** file: counts the amount of characters, words, and lines in the given file; can also count the same values of whatever it receives via stdin    
- **file** file: prints the type of the given file, as recognized by the operating system
- **head** file: shows the first 10 lines of the given file    
- **tail** file: shows the last 10 lines of the given file
- **less** file: scrolls through the contents of the given file (press "q" to quit)
- **sort** file: sorts the lines of the file alphabetically
- **cut -d** `<separator>` **-f** `<fields>` file: for each line in the given file, splits the line according to the given separator and prints the given fields (starting from 1)
### Additional commands
- **echo** "message": prints the message to standard output
- **date:** prints the current date
- **who:** prints the list of users currently logged into the computer
- **man**: shows the manual page of the given command; manual pages contain a lot of information explaining how to use each command (press "q" to quit)
- **uptime:** shows how long the computer has been running
- **free:** shows the amount of unused memory on the current system

## Redirections, Pipes, and Signals
### Managing streams
These are the redirectors that we can use to take control of the streams of our programs
- command **>** file: redirects standard output, overwrites file
- command **>>** file: redirects standard output, appends to file
- command **<** file: redirects standard input from file
- command **2>** file: redirects standard error to file
- command1 **|** command2: connects the output of command1 to the input of command2
### Operating with processes
These are some commands that are useful to know in Linux when interacting with processes. Not all of them are explained in videos, so feel free to investigate them on your own.
- **ps:** lists the processes executing in the current terminal for the current user
- **ps** ax: lists all processes currently executing for all users
- **ps** e: shows the environment for the processes listed
- **kill** PID: sends the SIGTERM signal to the process identified by PID
- **fg**: causes a job that was stopped or in the background to return to the foreground
- **bg:** causes a job that was stopped to go to the background
- **jobs:** lists the jobs currently running or stopped
- **top:** shows the processes currently using the most CPU time (press "q" to quit)